# -*- coding: utf-8 -*-
"""Untitled29.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sPGP69uedNGpZRm_md2wsUdPXh6QxMKv
"""

import streamlit as st
import pandas as pd
import numpy as np
import copy
import os
import plotly.graph_objects as go
import time

st.set_page_config(layout="wide")
st.title('Optimizador de Ruta con Algoritmo Gen√©tico')
st.markdown("Esta aplicaci√≥n utiliza un **algoritmo gen√©tico** para encontrar una ruta de alta calidad para el Problema del Vendedor Viajero (TSP) en Colombia.")

# --- PAR√ÅMETROS ---
MUTATION_RATE = 0.18
CROSSOVER_RATE = 0.9
POPULATION_SIZE = 250
ELITISM_RATE = 0.1
N_ITERATIONS = 500
TOURNAMENT_SIZE = 7
EARLY_STOPPING_PATIENCE = 200

# --- L√ìGICA DEL ALGORITMO ---
@st.cache_data
def load_colombia_data():
    coords_file = 'ubicacion.csv'
    dist_file = 'distancias.csv'
    if not os.path.exists(coords_file) or not os.path.exists(dist_file):
        st.error(f"Error: Aseg√∫rate de que los archivos '{coords_file}' y '{dist_file}' existan.")
        return None, None
    cities = pd.read_csv(coords_file)
    distance_matrix_df = pd.read_csv(dist_file, index_col='Ciudad')
    distance_matrix = distance_matrix_df.to_numpy()
    return cities, distance_matrix

CITIES, DISTANCE_MATRIX = load_colombia_data()

class TSPCandidate:
    def __init__(self, chromosomes=None):
        if chromosomes is None:
            self.chromosomes = np.arange(len(CITIES))
            np.random.shuffle(self.chromosomes)
        else:
            self.chromosomes = chromosomes
        self._fitness = None

    @property
    def fitness_score(self) -> float:
        if self._fitness is None:
            rolled_chromosomes = np.roll(self.chromosomes, -1)
            distances = DISTANCE_MATRIX[self.chromosomes, rolled_chromosomes]
            self._fitness = np.sum(distances)
        return self._fitness

    def mutate(self):
        if np.random.rand() < MUTATION_RATE:
            if np.random.rand() < 0.5:
                idx1, idx2 = np.random.choice(len(self.chromosomes), 2, replace=False)
                self.chromosomes[idx1], self.chromosomes[idx2] = self.chromosomes[idx2], self.chromosomes[idx1]
            else:
                start, end = np.sort(np.random.choice(len(self.chromosomes), 2, replace=False))
                self.chromosomes[start:end+1] = self.chromosomes[start:end+1][::-1]
            self._fitness = None

    def crossover(self, other_parent: "TSPCandidate") -> "TSPCandidate":
        p1, p2 = self.chromosomes, other_parent.chromosomes
        n_genes = len(p1)
        start, end = np.sort(np.random.choice(n_genes, 2, replace=False))
        child_chromo = np.full(n_genes, -1, dtype=int)
        child_chromo[start:end+1] = p1[start:end+1]
        
        p2_idx = 0
        for i in range(n_genes):
            if child_chromo[i] == -1:
                while p2[p2_idx] in child_chromo:
                    p2_idx += 1
                child_chromo[i] = p2[p2_idx]
        return TSPCandidate(chromosomes=child_chromo)

class Population:
    def __init__(self, size):
        self.candidates = [TSPCandidate() for _ in range(size)]

    def evolve(self, elitism_rate, crossover_rate, tournament_size):
        self.candidates.sort(key=lambda c: c.fitness_score)
        elitism_size = int(len(self.candidates) * elitism_rate)
        next_gen = self.candidates[:elitism_size]

        while len(next_gen) < len(self.candidates):
            p1 = self._tournament_selection(tournament_size)
            p2 = self._tournament_selection(tournament_size)
            child = p1.crossover(p2) if np.random.rand() < crossover_rate else copy.deepcopy(p1)
            child.mutate()
            next_gen.append(child)
        self.candidates = next_gen

    def _tournament_selection(self, tournament_size) -> "TSPCandidate":
        competitors = np.random.choice(self.candidates, tournament_size, replace=False)
        return min(competitors, key=lambda c: c.fitness_score)

def draw_map_genetic(cities_df, route_indices=None, title=""):
    fig = go.Figure()
    fig.add_trace(go.Scattermapbox(lat=cities_df['Latitud'], lon=cities_df['Longitud'], mode='markers+text',
                                     marker={'size': 10, 'color': 'darkblue'}, text=cities_df['Capital'], textposition='top right'))
    if route_indices is not None:
        route_points = cities_df.iloc[np.append(route_indices, route_indices[0])]
        fig.add_trace(go.Scattermapbox(lat=route_points['Latitud'], lon=route_points['Longitud'], mode='lines',
                                       line={'width': 2, 'color': 'crimson'}, name="Ruta"))
    fig.update_layout(title=title, showlegend=False, mapbox_style="carto-positron", mapbox_zoom=3.85,
                      mapbox_center={"lat": 4.5709, "lon": -74.2973}, margin={"r":0,"t":40,"l":0,"b":0})
    return fig

# --- INTERFAZ DE STREAMLIT ---
if 'final_solution_data' not in st.session_state:
    st.session_state['final_solution_data'] = None

if CITIES is not None:
    with st.expander("Haz clic para ver los Componentes del Algoritmo Gen√©tico"):
        st.markdown(r"""
        Un **algoritmo gen√©tico (AG)** es una heur√≠stica que imita la evoluci√≥n natural para encontrar soluciones de alta calidad.
        * **Candidato (o Individuo)**: Una soluci√≥n potencial al problema. En el TSP, un candidato es una ruta espec√≠fica, representada como una secuencia ordenada de ciudades (un "cromosoma").
        * **Poblaci√≥n**: Un conjunto de candidatos. El AG mantiene una poblaci√≥n de diversas rutas en cada generaci√≥n.
        * **Funci√≥n de Fitness**: Mide qu√© tan buena es una soluci√≥n. Para el TSP, el fitness es la distancia total de la ruta. Un valor m√°s bajo es mejor.
        * **Selecci√≥n**: Proceso de elegir a los "padres" de la siguiente generaci√≥n. Las rutas con menor distancia (mejor fitness) tienen m√°s probabilidades de ser seleccionadas. Usamos la **Selecci√≥n por Torneo**: se elige un subconjunto aleatorio de la poblaci√≥n y el mejor de ese subconjunto es seleccionado.
        * **Cruce (Crossover)**: Combina dos soluciones "padre" para crear un "hijo", con la esperanza de que herede las mejores caracter√≠sticas de ambos.
        * **Mutaci√≥n**: Introduce peque√±os cambios aleatorios en un candidato. Esto mantiene la diversidad gen√©tica y evita que el algoritmo se estanque en una soluci√≥n sub√≥ptima.
        * **Elitismo**: Garantiza que los mejores candidatos de una generaci√≥n pasen directamente a la siguiente sin cambios.
        """)

    col1, col2 = st.columns([1, 2])

    with col2:
        # CAMBIO: Invertir el orden de los placeholders
        map_placeholder = st.empty()
        summary_placeholder = st.empty()
        map_placeholder.plotly_chart(draw_map_genetic(CITIES, title="Capitales de Colombia"), use_container_width=True)

    with col1:
        if st.button('üß¨ Resolver con M√©todo Gen√©tico', key="solve_button"):
            st.session_state['final_solution_data'] = None
            
            np.random.seed(123)
            population = Population(POPULATION_SIZE)
            best_overall_score = float('inf')
            best_iteration = 0
            generations_without_improvement = 0

            for i in range(N_ITERATIONS):
                population.evolve(ELITISM_RATE, CROSSOVER_RATE, TOURNAMENT_SIZE)
                current_best_candidate = population.candidates[0]
                
                new_best_found = current_best_candidate.fitness_score < best_overall_score
                if new_best_found:
                    best_overall_score = current_best_candidate.fitness_score
                    best_iteration = i + 1
                    generations_without_improvement = 0
                else:
                    generations_without_improvement += 1

                if new_best_found or (i + 1) % 25 == 0:
                    # CAMBIO: El orden de actualizaci√≥n no importa, solo el de creaci√≥n
                    map_placeholder.plotly_chart(draw_map_genetic(CITIES, current_best_candidate.chromosomes, f"Mejor Ruta en Generaci√≥n {i+1}"), use_container_width=True)
                    summary_placeholder.info(f"Generaci√≥n {i+1}/{N_ITERATIONS}\n\nMejor Distancia: {best_overall_score:,.2f} km")
                    if new_best_found:
                        time.sleep(1.2)

                if generations_without_improvement >= EARLY_STOPPING_PATIENCE:
                    st.toast(f"Parada temprana en generaci√≥n {i+1}.")
                    break
            
            best_final_solution = min(population.candidates, key=lambda c: c.fitness_score)
            map_placeholder.plotly_chart(draw_map_genetic(CITIES, best_final_solution.chromosomes, "Ruta √ìptima Final Encontrada"), use_container_width=True)
            summary_placeholder.success("¬°Optimizaci√≥n Completada!")
            
            st.session_state['final_solution_data'] = {
                "solution": best_final_solution,
                "iteration": best_iteration
            }

    results_container = st.container()

    if st.session_state['final_solution_data'] is not None:
        final_data = st.session_state['final_solution_data']
        best_final_solution = final_data["solution"]
        optimal_iteration = final_data["iteration"]

        with results_container:
            st.markdown("---")
            st.header("üèÜ Mejor Soluci√≥n Encontrada üèÜ")
            
            res_col1, res_col2 = st.columns(2)
            with res_col1:
                st.metric(label="Distancia Final (Heur√≠stica)", value=f"{best_final_solution.fitness_score:,.2f} km")
            with res_col2:
                st.metric(label="Iteraci√≥n √ìptima Encontrada", value=f"#{optimal_iteration}")

            ordered_capitals = CITIES.iloc[best_final_solution.chromosomes]['Capital'].tolist()
            st.subheader("Orden de Visita Sugerido:")
            route_str = " ‚Üí ".join(ordered_capitals) + " ‚Üí " + ordered_capitals[0]
            st.text_area("Ruta", route_str, height=150, key="final_route_text")

elif CITIES is None:
    st.error("Error al cargar los datos.")