# -*- coding: utf-8 -*-
"""Untitled29.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sPGP69uedNGpZRm_md2wsUdPXh6QxMKv
"""

import streamlit as st
import pandas as pd
import numpy as np
import copy
import os
import plotly.graph_objects as go
import time

# =============================================================================
# CONFIGURACIÓN DEL ALGORITMO GENÉTICO Y LA APP
# =============================================================================
st.set_page_config(layout="wide")
st.title('Optimizador de Ruta del Vendedor Viajero (TSP) para Colombia')
st.markdown("Esta aplicación utiliza un **algoritmo genético** para encontrar la ruta más corta que conecta las capitales de Colombia.")

# PARÁMETROS DEL ALGORITMO
MUTATION_RATE = 0.2
CROSSOVER_RATE = 0.9
POPULATION_SIZE = 250
ELITISM_RATE = 0.1
N_ITERATIONS = 400
TOURNAMENT_SIZE = 7
EARLY_STOPPING_PATIENCE = 100

# Semilla para reproducibilidad
seed_value = 123
np.random.seed(seed_value)

# =============================================================================
# CARGA DE DATOS
# =============================================================================
@st.cache_data
def load_colombia_data():
    """
    Carga los datos de las capitales de Colombia desde los archivos CSV.
    Se ejecuta una sola vez gracias al decorador de cache de Streamlit.
    """
    coords_file = 'ubicacion.csv'
    dist_file = 'distancias.csv'

    if not os.path.exists(coords_file) or not os.path.exists(dist_file):
        st.error(f"Error: Asegúrate de que los archivos '{coords_file}' y '{dist_file}' existan en el directorio.")
        return None, None

    cities = pd.read_csv(coords_file)
    distance_matrix_df = pd.read_csv(dist_file, index_col='Ciudad')
    distance_matrix = distance_matrix_df.to_numpy()

    st.success("Datos de Colombia cargados exitosamente.")
    return cities, distance_matrix

CITIES, DISTANCE_MATRIX = load_colombia_data()

# =============================================================================
# CLASES DEL ALGORITMO GENÉTICO (Con la corrección)
# =============================================================================

class TSPCandidate:
    def __init__(self):
        self.chromosomes = np.arange(len(CITIES))
        np.random.shuffle(self.chromosomes)
        self._fitness = None

    @property
    def fitness_score(self) -> float:
        if self._fitness is None:
            rolled_chromosomes = np.roll(self.chromosomes, -1)
            distances = DISTANCE_MATRIX[self.chromosomes, rolled_chromosomes]
            self._fitness = np.sum(distances)
        return self._fitness

    def mutate(self):
        if np.random.rand() < MUTATION_RATE:
            if np.random.rand() < 0.5:
                swap_indices = np.random.choice(len(self.chromosomes), size=2, replace=False)
                self.chromosomes[swap_indices[0]], self.chromosomes[swap_indices[1]] = \
                    self.chromosomes[swap_indices[1]], self.chromosomes[swap_indices[0]]
            else:
                start, end = np.sort(np.random.choice(len(self.chromosomes), size=2, replace=False))
                self.chromosomes[start:end] = self.chromosomes[start:end][::-1]
            self._fitness = None

    def crossover(self, other_parent: "TSPCandidate") -> "TSPCandidate":
        child = TSPCandidate()
        p1, p2 = self.chromosomes, other_parent.chromosomes
        n_genes = len(p1)
        start, end = np.sort(np.random.choice(n_genes, 2, replace=False))
        child_chromo = np.full(n_genes, -1, dtype=int)
        child_chromo[start:end] = p1[start:end]
        p1_segment_set = set(p1[start:end])
        p2_genes_to_add = [gene for gene in p2 if gene not in p1_segment_set]
        p2_idx = 0
        for i in list(range(end, n_genes)) + list(range(start)):
            child_chromo[i] = p2_genes_to_add[p2_idx]
            p2_idx += 1
        child.chromosomes = child_chromo
        child._fitness = None
        return child

class Population:
    def __init__(self):
        self.candidates = [TSPCandidate() for _ in range(POPULATION_SIZE)]

    def sort_candidates(self):
        self.candidates.sort(key=lambda c: c.fitness_score)

    def _tournament_selection(self) -> "TSPCandidate":
        tournament_group = np.random.choice(self.candidates, size=TOURNAMENT_SIZE, replace=False)
        winner = min(tournament_group, key=lambda c: c.fitness_score)
        return winner

    def evolve(self):
        self.sort_candidates()
        elitism_size = int(POPULATION_SIZE * ELITISM_RATE)
        next_gen = self.candidates[:elitism_size]
        while len(next_gen) < POPULATION_SIZE:
            parent1 = self._tournament_selection()
            parent2 = self._tournament_selection()
            if np.random.rand() < CROSSOVER_RATE:
                child = parent1.crossover(parent2)
            else:
                child = copy.deepcopy(parent1)
            child.mutate()
            next_gen.append(child)
        self.candidates = next_gen

    @property
    def statistics(self):
        """
        Calcula y devuelve las estadísticas de la población actual.
        Este es el método que faltaba.
        """
        scores = [c.fitness_score for c in self.candidates]
        return {'min_dist': np.min(scores), 'mean_dist': np.mean(scores)}

# =============================================================================
# FUNCIONES DE VISUALIZACIÓN
# =============================================================================

def draw_map(cities_df, route_indices=None, title=""):
    """
    Dibuja el mapa de Colombia con las ciudades y opcionalmente una ruta.
    """
    fig = go.Figure()

    # Añadir las ciudades como marcadores
    fig.add_trace(go.Scattermapbox(
        lat=cities_df['Latitud'],
        lon=cities_df['Longitud'],
        mode='markers+text',
        marker=go.scattermapbox.Marker(size=10, color='darkblue'),
        text=cities_df['Capital'],
        textposition='top right'
    ))

    # Añadir la ruta si se proporciona
    if route_indices is not None:
        route_points = cities_df.iloc[route_indices]
        # Añadir el punto de inicio para cerrar el ciclo
        route_points = pd.concat([route_points, route_points.iloc[:1]], ignore_index=True)

        fig.add_trace(go.Scattermapbox(
            lat=route_points['Latitud'],
            lon=route_points['Longitud'],
            mode='lines',
            line=go.scattermapbox.Line(width=2, color='crimson'),
            name="Ruta"
        ))

    # Actualizar el layout del mapa
    fig.update_layout(
        title=title,
        showlegend=False,
        mapbox_style="carto-positron",
        mapbox_zoom=4,
        mapbox_center={"lat": 4.5709, "lon": -74.2973},
        margin={"r":0, "t":40, "l":0, "b":0}
    )
    return fig

# =============================================================================
# LÓGICA DE LA APLICACIÓN STREAMLIT
# =============================================================================

if CITIES is not None:
    # Placeholders para los elementos que se actualizarán dinámicamente
    summary_placeholder = st.empty()
    map_placeholder = st.empty()

    # Mostrar el mapa inicial con todas las ciudades
    map_placeholder.plotly_chart(draw_map(CITIES, title="Capitales de Colombia"), use_container_width=True)

    if st.button('🚀 Iniciar Optimización'):

        population = Population()
        population.sort_candidates()
        initial_solution = copy.deepcopy(population.candidates[0])

        summary_placeholder.info(f"--- Solución Inicial Aleatoria ---\nDistancia: {initial_solution.fitness_score:.2f} km")
        map_placeholder.plotly_chart(draw_map(CITIES, initial_solution.chromosomes, "Ruta Inicial Aleatoria"), use_container_width=True)
        time.sleep(1)

        best_overall_score = initial_solution.fitness_score
        generations_without_improvement = 0

        for i in range(N_ITERATIONS):
            population.evolve()
            stats = population.statistics
            current_best_score = stats['min_dist']

            if current_best_score < best_overall_score:
                best_overall_score = current_best_score
                generations_without_improvement = 0

                # Actualizar la UI con la nueva mejor ruta encontrada
                population.sort_candidates()
                best_candidate = population.candidates[0]

                summary_text = f"""
                **Generación {i+1}/{N_ITERATIONS}** | **Mejor Distancia Actual: {current_best_score:.2f} km**

                *Generaciones sin mejora: {generations_without_improvement}*
                """
                summary_placeholder.info(summary_text)
                map_placeholder.plotly_chart(draw_map(CITIES, best_candidate.chromosomes, f"Mejor Ruta en Generación {i+1}"), use_container_width=True)

            else:
                generations_without_improvement += 1

            if (i + 1) % 50 == 0:
                 summary_text = f"""
                **Generación {i+1}/{N_ITERATIONS}** | **Mejor Distancia Actual: {current_best_score:.2f} km**

                *Generaciones sin mejora: {generations_without_improvement}*
                """
                 summary_placeholder.info(summary_text)


            if generations_without_improvement >= EARLY_STOPPING_PATIENCE:
                st.warning(f"--- Parada Temprana: La solución no ha mejorado en {EARLY_STOPPING_PATIENCE} generaciones. Deteniendo en la generación {i+1}. ---")
                break

        # Mostrar el resultado final
        population.sort_candidates()
        best_final_solution = population.candidates[0]

        st.markdown("---")
        st.header("🏆 Mejor Solución Encontrada 🏆")
        st.metric(label="Distancia Final Óptima", value=f"{best_final_solution.fitness_score:.2f} km")

        ordered_capitals = CITIES.iloc[best_final_solution.chromosomes]['Capital'].tolist()
        st.subheader("Orden de Visita Sugerido:")
        st.info(" -> ".join(ordered_capitals))

        # Actualizar el mapa y el resumen por última vez
        summary_placeholder.success("¡Optimización Completada!")
        map_placeholder.plotly_chart(draw_map(CITIES, best_final_solution.chromosomes, "Ruta Óptima Final"), use_container_width=True)